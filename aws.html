<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.7.1">
<title>Introduction</title>
<link rel="stylesheet" href="css/spring.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="http://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

$(addBlockSwitches);
</script>
</head>

<body class="book toc2 toc-left">
<div id="header">
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_functional_bean_definitions">Functional Bean Definitions</a></li>
<li><a href="#_platform_specific_features">Platform Specific Features</a>
<ul class="sectlevel2">
<li><a href="#_http_and_api_gateway">HTTP and API Gateway</a></li>
</ul>
</li>
<li><a href="#_custom_runtime">Custom Runtime</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong>2.1.0.BUILD-SNAPSHOT</strong></p>
</div>
<div id="index-link" class="paragraph">
<p><a href="https://cloud.spring.io/spring-cloud-function/home.html" class="bare">https://cloud.spring.io/spring-cloud-function/home.html</a></p>
</div>
<div class="paragraph">
<p>The <a href="https://aws.amazon.com/">AWS</a> adapter takes a Spring Cloud Function app and converts it to a form that can run in AWS Lambda.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction"><a class="link" href="#_introduction">Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in aws.adoc - include::aws-intro.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_functional_bean_definitions"><a class="link" href="#_functional_bean_definitions">Functional Bean Definitions</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Your functions will start much quicker if you can use functional bean definitions instead of <code>@Bean</code>. To do this make your main class
an <code>ApplicationContextInitializer&lt;GenericApplicationContext&gt;</code> and use the <code>registerBean()</code> methods in <code>GenericApplicationContext</code> to
create all the beans you need. You function need sto be registered as a bean of type <code>FunctionRegistration</code> so that the input and
output types can be accessed by the framework. There is an example in github (the AWS sample is written in this style). It would
look something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@SpringBootApplication
public class FuncApplication implements ApplicationContextInitializer&lt;GenericApplicationContext&gt; {

	public static void main(String[] args) throws Exception {
		FunctionalSpringApplication.run(FuncApplication.class, args);
	}

	public Function&lt;Foo, Bar&gt; function() {
		return value -&gt; new Bar(value.uppercase()));
	}

	@Override
	public void initialize(GenericApplicationContext context) {
		context.registerBean("function", FunctionRegistration.class,
			() -&gt; new FunctionRegistration&lt;Function&lt;Foo, Bar&gt;&gt;(function())
				.type(FunctionType.from(Foo.class).to(Bar.class).getType()));
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_platform_specific_features"><a class="link" href="#_platform_specific_features">Platform Specific Features</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_http_and_api_gateway"><a class="link" href="#_http_and_api_gateway">HTTP and API Gateway</a></h3>
<div class="paragraph">
<p>AWS has some platform-specific data types, including batching of messages, which is much more efficient than processing each one individually. To make use of these types you can write a function that depends on those types. Or you can rely on Spring to extract the data from the AWS types and convert it to a Spring <code>Message</code>. To do this you tell AWS that the function is of a specific generic handler type (depending on the AWS service) and provide a bean of type <code>Function&lt;Message&lt;S&gt;,Message&lt;T&gt;&gt;</code>, where <code>S</code> and <code>T</code> are your business data types. If there is more than one bean of type <code>Function</code> you may also need to configure the Spring Boot property <code>function.name</code> to be the name of the target bean (e.g. use <code>FUNCTION_NAME</code> as an environment variable).</p>
</div>
<div class="paragraph">
<p>The supported AWS services and generic handler types are listed below:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Service</th>
<th class="tableblock halign-left valign-top">AWS Types</th>
<th class="tableblock halign-left valign-top">Generic Handler</th>
<th class="tableblock halign-left valign-top"></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">API Gateway</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>APIGatewayProxyRequestEvent</code>, <code>APIGatewayProxyResponseEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kinesis</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">KinesisEvent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">org.springframework.cloud.function.adapter.aws.SpringBootKinesisEventHandler</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For example, to deploy behind an API Gateway, use <code>--handler org.springframework.cloud.function.adapter.aws.SpringBootApiGatewayRequestHandler</code> in your AWS command line (in via the UI) and define a <code>@Bean</code> of type <code>Function&lt;Message&lt;Foo&gt;,Message&lt;Bar&gt;&gt;</code> where <code>Foo</code> and <code>Bar</code> are POJO types (the data will be marshalled and unmarshalled by AWS using Jackson).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_custom_runtime"><a class="link" href="#_custom_runtime">Custom Runtime</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html">AWS Lambda custom runtime</a> can be created really easily using the HTTP export features in Spring Cloud Function Web. To make this work just add Spring Cloud Function AWS and Spring Cloud Function Web as dependencies in your project and set the following in your <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>spring.cloud.function.web.export.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Set the handler name in AWS to the name of your function. Then provide a <code>bootstrap</code> script in the root of your zip/jar that runs the Spring Boot application. The functional bean definition style works for custom runtimes too, and is faster than the <code>@Bean</code> style, so the example <code>FuncApplication</code> above would work. A custom runtime can start up much quicker even than a functional bean implementation of a Java lambda - it depends mostly on the number of classes you need to load at runtime. Spring doesn&#8217;t do very much here, so you can reduce the cold start time by only using primitive types in your function, for instance, and not doing any work in custom <code>@PostConstruct</code> initializers.</p>
</div>
</div>
</div>
</div>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<link rel="stylesheet" href="js/highlight/styles/atom-one-dark-reasonable.min.css">
<script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>